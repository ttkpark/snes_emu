# IPL ROM 프로토콜 상세 설명

## IPL ROM 개요
- **위치**: 0xFFC0-0xFFFF (64 바이트)
- **역할**: SPC700 부팅 시 CPU로부터 SPC 프로그램을 받아서 ARAM에 로드하고 실행
- **처리 방식**: IPL ROM이 직접 명령어를 실행하여 처리 (줄글로 처리하는 것이 아님)

## 전체 프로토콜 단계

### Phase 1: 초기화 (0xFFC0-0xFFCC)

#### 0xFFC0: `MOV X, #$EF`
- **레지스터**: X = 0xEF
- **목적**: 스택 포인터 초기화 준비

#### 0xFFC2: `MOV SP, X`
- **레지스터**: SP = X = 0xEF
- **목적**: 스택 포인터 설정 (0x01EF)

#### 0xFFC3: `MOV A, #$00`
- **레지스터**: A = 0x00
- **목적**: ARAM 클리어를 위한 값

#### 0xFFC5-0xFFC7: ARAM 클리어 루프
```
0xFFC5: MOV (X), A    ; ARAM[X] = A (0x00)
0xFFC6: DEC X         ; X--
0xFFC7: BNE $FFC5     ; X != 0이면 루프
```
- **레지스터**: X가 0xEF에서 0x00까지 감소
- **메모리**: ARAM[0x00-0xEF] = 0x00
- **목적**: Direct Page 영역 클리어

#### 0xFFC9: `MOV $F4, #$AA`
- **레지스터**: A = 0xAA (이전 명령에서)
- **메모리**: $F4 (포트 0) = 0xAA
- **CPU 측**: CPU가 $2140을 읽으면 0xAA 반환
- **목적**: Ready 신호 (포트 0 = 0xAA)

#### 0xFFCC: `MOV $F5, #$BB`
- **레지스터**: A = 0xBB
- **메모리**: $F5 (포트 1) = 0xBB
- **CPU 측**: CPU가 $2141을 읽으면 0xBB 반환
- **목적**: Ready 신호 (포트 1 = 0xBB)
- **CPU 확인**: CPU는 $2140/$2141에서 0xBBAA를 읽어야 함

### Phase 2: 0xCC 대기 (0xFFCF-0xFFD3)

#### 0xFFCF: `CMP $F4, #$CC`
- **레지스터**: A와 $F4 (포트 0) 비교
- **CPU 측**: CPU가 $2140에 0xCC를 씀
- **SPC 측**: $F4를 읽어서 0xCC인지 확인
- **플래그**: Z 플래그 설정 (A == $F4이면 Z=1)

#### 0xFFD2: `BNE $FFCF`
- **조건**: Z=0이면 (A != $F4) 루프
- **목적**: CPU가 0xCC를 쓸 때까지 대기

#### 0xFFD4: `BRA $FFEF`
- **목적**: 데이터 수신 루프로 점프 (0xCC를 받았으므로)

### Phase 3: 데이터 수신 루프 (0xFFD6-0xFFEE)

#### 0xFFD6: `MOV Y, $F4` (또는 `MOV A, $F4` - 수정된 버전)
- **레지스터**: Y = $F4 (포트 0)
- **CPU 측**: CPU가 포트 0에 데이터 인덱스/명령을 씀
- **목적**: 포트 0 값 읽기

#### 0xFFD8: `BNE $FFD6`
- **조건**: Y != 0이면 루프
- **목적**: 포트 0이 0이 될 때까지 대기 (데이터 전송 완료 신호)

#### 0xFFDA: `CMP Y, $F4`
- **레지스터**: Y와 $F4 비교
- **목적**: 포트 0 값이 변경되었는지 확인

#### 0xFFDC: `BNE $FFE9`
- **조건**: Y != $F4이면 (포트 0이 변경됨) 분기
- **목적**: 새로운 데이터가 있으면 수신 루프로

#### 0xFFDE: `MOV A, $F5`
- **레지스터**: A = $F5 (포트 1)
- **CPU 측**: CPU가 포트 1에 데이터 바이트를 씀
- **목적**: 데이터 바이트 읽기

#### 0xFFE0: `MOV Y, $F4`
- **레지스터**: Y = $F4 (포트 0)
- **CPU 측**: CPU가 포트 0에 인덱스를 씀
- **목적**: 인덱스 읽기

#### 0xFFE2: `MOV ($00)+Y, A`
- **레지스터**: 목적지 주소 = ($00) + Y
- **메모리**: ARAM[($00) + Y] = A (데이터 바이트)
- **목적**: ARAM에 데이터 쓰기

#### 0xFFE4: `INC Y`
- **레지스터**: Y++
- **목적**: 인덱스 증가

#### 0xFFE5: `BNE $FFDA`
- **조건**: Y != 0이면 루프
- **목적**: 인덱스가 0이 되면 (256 바이트 전송 완료) 다음 단계로

#### 0xFFE7: `INC $01`
- **메모리**: $01++ (목적지 주소 상위 바이트 증가)
- **목적**: 256 바이트 경계 넘어가기

#### 0xFFE9: `BPL $FFDA`
- **조건**: N=0이면 (양수) 루프
- **목적**: 데이터 전송 계속

#### 0xFFEB: `CMP Y, $F4`
- **레지스터**: Y와 $F4 비교
- **목적**: 전송 완료 확인

#### 0xFFED: `BPL $FFDA`
- **조건**: N=0이면 루프
- **목적**: 전송 계속

### Phase 4: 실행 주소 설정 및 Echo (0xFFEF-0xFFFA)

#### 0xFFEF: `MOVW YA, $F6`
- **레지스터**: YA = ($F6, $F7) (16비트)
- **CPU 측**: CPU가 포트 2/3에 실행 주소를 씀
- **목적**: 실행 주소 읽기

#### 0xFFF1: `MOVW $00, YA`
- **메모리**: ($00, $01) = YA
- **목적**: 실행 주소를 $00-$01에 저장

#### 0xFFF3: `MOVW YA, $F4`
- **레지스터**: YA = ($F4, $F5) (포트 0/1)
- **CPU 측**: CPU가 포트 0에 실행 명령(예: 0x77)을 씀
- **목적**: 실행 명령 읽기

#### 0xFFF5: `MOV $F4, A` ⭐ **ECHO!**
- **레지스터**: A를 포트 0에 쓰기
- **메모리**: $F4 = A (실행 명령 값)
- **CPU 측**: CPU가 $2140을 읽으면 실행 명령 값 반환
- **목적**: CPU에게 echo (CPU가 `@wait4` 루프 탈출 가능)

#### 0xFFF7: `MOV A, Y`
- **레지스터**: A = Y
- **목적**: 포트 1 값 확인

#### 0xFFF8: `MOV X, A`
- **레지스터**: X = A
- **목적**: 포트 1 값 저장

#### 0xFFF9: `BNE $FFD6`
- **조건**: X != 0이면 데이터 수신 루프로
- **목적**: 포트 1이 0이 아니면 추가 데이터 전송

### Phase 5: SPC 프로그램 실행 (0xFFFB-0xFFFD)

#### 0xFFFB: `JMP ($00+X)`
- **레지스터**: X = 0 (포트 1이 0이므로)
- **메모리**: 목적지 = ($00, $01) (실행 주소)
- **목적**: SPC 프로그램으로 점프
- **결과**: PC = 실행 주소 (예: 0x0300)

## 현재 문제점

현재 에뮬레이터에서는:
- **APU 코드에서 직접 echo 처리**: `m_aram[0xF4] = value;` (580번째 줄)
- **IPL ROM이 실행되지 않음**: echo는 IPL ROM의 0xFFF5에서 처리되어야 함

**올바른 동작**:
1. CPU가 포트 0에 0x77 쓰기
2. IPL ROM이 0xFFF3에서 `MOVW YA, $F4` 실행 → A = 0x77
3. IPL ROM이 0xFFF5에서 `MOV $F4, A` 실행 → 포트 0에 0x77 echo
4. CPU가 포트 0에서 0x77 읽기 → `@wait4` 루프 탈출
5. IPL ROM이 0xFFFB에서 `JMP ($00+X)` 실행 → PC = 0x0300
6. SPC 프로그램이 0x0300에서 시작 → `MOV $F4, #$00` 실행

**현재 잘못된 동작**:
1. CPU가 포트 0에 0x77 쓰기
2. APU 코드에서 직접 `m_aram[0xF4] = 0x77` 설정
3. 바로 `m_regs.pc = 0x0300` 설정
4. SPC 프로그램이 실행되어 `MOV $F4, #$00` 실행
5. CPU가 포트 0에서 0x00 읽기 (아직 echo를 읽지 못함)
6. `@wait4` 루프에서 탈출하지 못함

## 해결 방법

APU 코드에서 직접 echo를 처리하지 말고, IPL ROM이 실행되도록 해야 합니다.
IPL ROM이 0xFFF5에서 echo를 처리하고, 그 후에 0xFFFB에서 SPC 프로그램으로 점프해야 합니다.

