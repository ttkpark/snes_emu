# 65C816 test ROM

This is an SNES ROM that performs comprehensive testing of the 65C816 instruction set.

There are two versions of the ROM:
- cputest-full.sfc performs all the tests.
- cputest-basic.sfc skips some of the tests unlikely to be used by games, such as wrapping behavior in emulation mode.

If a test fails, see the autogenerated tests-\*.txt or tests-\*.inc files for details about the test.

### The ROM tests the following:

- All 65C816 opcodes except STP and WAI
- Each instruction is tested in all supported addressing modes
- Multiple tests per instruction, designed to test edge cases and correct flag result
- Wrapping behavior of various addressing modes for all instructions, with and without emulation mode

### The ROM does *not* test:

- Cycle count taken by instructions, or other timing-related behavior
- Hardware interrupts
- Memory-mapped registers

## Building:

The required tools are ca65/ld65 and Python 3.

Either use the Makefile by running `make`, or run:

    python3 make_cpu_tests.py
    ca65 main.asm -o cputest.o
    ld65 -C lorom.cfg -o cputest.sfc cputest.o

The above will generate the full sfc. For only basic tests, add `--basic` to the Python command, and `-D basic` to the ca65 command.

## FAQ

### How do I find out what a test does?

The autogenerated tests-\*.txt file (generated when building and available in the release zip) contains a 
description of each test, including the input and expected output register/memory values. For more
details, see the autogenerated tests-full.inc or tests-basic.inc assembly file. To debug a test, look for its
address in tests.map.

### What undocumented behavior is testsed?

- In emulation mode with S=$1FF, the PLB instruction should read from $200 instead of $100. This is despite
the fact that the CPU manual doesn't list it with the instructions that can access outside the stack page.
- In emulation mode when the low byte of D is nonzero, the (direct,X) addressing mode behaves strangely:  
  The low byte of the indirect address is read from `direct_addr+X+D` without page wrapping (as expected). The high byte is read from `direct_addr+X+D+1`, but the +1 is done *with* wrapping within the page.
  For example: Emulation=1, D=$11A, X=$EE, and the instruction is `lda ($F7,X)`. Here $F7 + $11A + $EE = $2FF. The low byte of the address is read from $2FF and the high byte from $200.
  This behavior only applies to this addressing mode, and not to other indirect modes.
- The behavior of decimal mode isn't fully documented. See appendix A of [this document](http://www.6502.org/tutorials/decimal_mode.html#A) for a full specification.