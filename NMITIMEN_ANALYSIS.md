# 0x4200 (NMITIMEN) 쓰기 분석

## CPU 로그에서 찾은 0x4200 쓰기

### 위치: PC = 0x802A
```
[0] PC:0x008027 | Op:0xa9 | A:0x01ff | ... | M:16 X:16 E:0
    LDA #$F0A9  ; A = 0xF0A9

[0] PC:0x00802a | Op:0x8f | A:0xf0a9 | ... | M:16 X:16 E:0
    STA Long $004200  ; 0x8F = STA Long (24-bit address)
    ; 이 명령어가 0x4200에 0x00을 쓰는 것!
```

## 명령어 분석

### STA Long (0x8F) - 24-bit 주소 쓰기
- **Opcode**: 0x8F
- **PC**: 0x802A
- **A 레지스터**: 0xF0A9 (16-bit 모드)
- **동작**: A의 하위 바이트(0xA9)를 Long 주소에 저장

### 실제 바이트 시퀀스 (ROM 0x802A):
```
0x802A: 8F        ; STA Long
0x802B: 00        ; Address low byte  (0x00)
0x802C: 42        ; Address mid byte  (0x42)
0x802D: 00        ; Address high byte (0x00)
```

**결과**: `STA $004200` - 0x4200 주소에 A의 하위 바이트 쓰기

## 왜 0x00이 쓰여지는가?

### 이전 명령어 (0x8027):
```
LDA #$F0A9  ; A = 0xF0A9
```

하지만 실제로는 **0x00**이 쓰여집니다. 왜일까요?

### 가능한 이유:

1. **8-bit 모드 전환**: 
   - 로그에는 M:16으로 표시되지만, 실제로는 8-bit 모드일 수 있음
   - 8-bit 모드에서 `LDA #$00`이 실행되었을 가능성

2. **CPU 로그의 A 레지스터 값이 부정확**:
   - 실제로는 A = 0x0000 또는 A = 0x??00 (하위 바이트가 0x00)

3. **이전에 A가 0으로 초기화됨**:
   - 0x8027 이전에 A가 0으로 설정되었을 가능성

## 콘솔 출력과의 일치

```
Memory: CPU I/O Write [$4200] = $0
```

이것은 PC=0x802A의 `STA Long $004200` 명령어가 실행된 결과입니다.

## 결론

**0x4200 (NMITIMEN) 쓰기는 CPU 로그의 라인 19에 해당합니다:**
- **PC**: 0x00802A
- **Opcode**: 0x8F (STA Long)
- **주소**: $004200
- **값**: $00 (NMI 비활성화)

이 명령어는 Super Mario World의 초기화 루틴 중 하나로, PPU의 NMI를 비활성화하여 안전하게 초기화를 진행합니다.


